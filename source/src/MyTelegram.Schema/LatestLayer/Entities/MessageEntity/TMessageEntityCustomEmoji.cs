// <auto-generated/>
// ReSharper disable All

namespace MyTelegram.Schema;

///<summary>
/// Represents a custom emoji.<br>
/// Note that this entity must wrap exactly one regular emoji (the one contained in <a href="https://corefork.telegram.org/constructor/documentAttributeCustomEmoji">documentAttributeCustomEmoji</a>.<code>alt</code>) in the related text, otherwise the server will ignore it.
/// See <a href="https://corefork.telegram.org/constructor/messageEntityCustomEmoji" />
///</summary>
[TlObject(0xc8cf05f8)]
public sealed class TMessageEntityCustomEmoji : IMessageEntity
{
    public uint ConstructorId => 0xc8cf05f8;
    ///<summary>
    /// Offset of message entity within message (in <a href="https://corefork.telegram.org/api/entities#entity-length">UTF-16 code units</a>)
    ///</summary>
    public int Offset { get; set; }

    ///<summary>
    /// Length of message entity within message (in <a href="https://corefork.telegram.org/api/entities#entity-length">UTF-16 code units</a>)
    ///</summary>
    public int Length { get; set; }

    ///<summary>
    /// Document ID of the <a href="https://corefork.telegram.org/api/custom-emoji">custom emoji</a>, use <a href="https://corefork.telegram.org/method/messages.getCustomEmojiDocuments">messages.getCustomEmojiDocuments</a> to fetch the emoji animation and the actual emoji it represents.
    ///</summary>
    public long DocumentId { get; set; }

    public void ComputeFlag()
    {

    }

    public void Serialize(IBufferWriter<byte> writer)
    {
        ComputeFlag();
        writer.Write(ConstructorId);
        writer.Write(Offset);
        writer.Write(Length);
        writer.Write(DocumentId);
    }

    public void Deserialize(ref ReadOnlyMemory<byte> buffer)
    {
        Offset = buffer.ReadInt32();
        Length = buffer.ReadInt32();
        DocumentId = buffer.ReadInt64();
    }
}