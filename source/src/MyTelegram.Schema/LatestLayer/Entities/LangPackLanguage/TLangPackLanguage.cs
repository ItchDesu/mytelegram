// <auto-generated/>
// ReSharper disable All

namespace MyTelegram.Schema;

///<summary>
/// Identifies a localization pack
/// See <a href="https://corefork.telegram.org/constructor/langPackLanguage" />
///</summary>
[TlObject(0xeeca5ce3)]
public sealed class TLangPackLanguage : ILangPackLanguage
{
    public uint ConstructorId => 0xeeca5ce3;
    ///<summary>
    /// Flags, see <a href="https://corefork.telegram.org/mtproto/TL-combinators#conditional-fields">TL conditional fields</a>
    ///</summary>
    public int Flags { get; set; }

    ///<summary>
    /// Whether the language pack is official
    /// See <a href="https://corefork.telegram.org/type/true" />
    ///</summary>
    public bool Official { get; set; }

    ///<summary>
    /// Is this a localization pack for an RTL language
    /// See <a href="https://corefork.telegram.org/type/true" />
    ///</summary>
    public bool Rtl { get; set; }

    ///<summary>
    /// Is this a beta localization pack?
    /// See <a href="https://corefork.telegram.org/type/true" />
    ///</summary>
    public bool Beta { get; set; }

    ///<summary>
    /// Language name
    ///</summary>
    public string Name { get; set; }

    ///<summary>
    /// Language name in the language itself
    ///</summary>
    public string NativeName { get; set; }

    ///<summary>
    /// Language code (pack identifier)
    ///</summary>
    public string LangCode { get; set; }

    ///<summary>
    /// Identifier of a base language pack; may be empty. If a string is missed in the language pack, then it should be fetched from base language pack. Unsupported in custom language packs
    ///</summary>
    public string? BaseLangCode { get; set; }

    ///<summary>
    /// A language code to be used to apply plural forms. See <a href="https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html">https://www.unicode.org/cldr/charts/latest/supplemental/language_plural_rules.html</a> for more info
    ///</summary>
    public string PluralCode { get; set; }

    ///<summary>
    /// Total number of non-deleted strings from the language pack
    ///</summary>
    public int StringsCount { get; set; }

    ///<summary>
    /// Total number of translated strings from the language pack
    ///</summary>
    public int TranslatedCount { get; set; }

    ///<summary>
    /// Link to language translation interface; empty for custom local language packs
    ///</summary>
    public string TranslationsUrl { get; set; }

    public void ComputeFlag()
    {
        if (Official) { Flags = Flags.SetBit(0); }
        if (Rtl) { Flags = Flags.SetBit(2); }
        if (Beta) { Flags = Flags.SetBit(3); }
        if (BaseLangCode != null) { Flags = Flags.SetBit(1); }

    }

    public void Serialize(IBufferWriter<byte> writer)
    {
        ComputeFlag();
        writer.Write(ConstructorId);
        writer.Write(Flags);
        writer.Write(Name);
        writer.Write(NativeName);
        writer.Write(LangCode);
        if (Flags.IsBitSet(1)) { writer.Write(BaseLangCode); }
        writer.Write(PluralCode);
        writer.Write(StringsCount);
        writer.Write(TranslatedCount);
        writer.Write(TranslationsUrl);
    }

    public void Deserialize(ref ReadOnlyMemory<byte> buffer)
    {
        Flags = buffer.ReadInt32();
        if (Flags.IsBitSet(0)) { Official = true; }
        if (Flags.IsBitSet(2)) { Rtl = true; }
        if (Flags.IsBitSet(3)) { Beta = true; }
        Name = buffer.ReadString();
        NativeName = buffer.ReadString();
        LangCode = buffer.ReadString();
        if (Flags.IsBitSet(1)) { BaseLangCode = buffer.ReadString(); }
        PluralCode = buffer.ReadString();
        StringsCount = buffer.ReadInt32();
        TranslatedCount = buffer.ReadInt32();
        TranslationsUrl = buffer.ReadString();
    }
}